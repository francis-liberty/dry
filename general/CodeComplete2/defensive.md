# Defensive Programming
## check invalid inputs
* all data from external sources
* all routine input arguments
* handle bad inputs

## Guidelines for using assertion
### Use error-handling code for conditions you expect to occur; use assertions for conditions that should never occur. 
**Error handling typically checks for bad input data; assertions check for bugs in the code.**

If error-handling code is used to address an anomalous condition, the error handling will enable the program to respond to the error gracefully. If an assertion is fired for an anomalous condition, the corrective action is not merely to handle an error gracefully—the corrective action is to change the program's source code, recompile, and release a new version of the software.

A good way to think of assertions is as executable documentation—you can't rely on them to make the code work, but they can document assumptions more actively than program-language comments can.

### Avoid putting executable code into assertions 
Putting code into an assertion raises the possibility that the compiler will eliminate the code when you turn off the assertions. 

### Use assertions to document and verify preconditions and postconditions
If the variables were coming from an external source, invalid values should be checked and handled by error-handling code rather than by assertions. If the variables are coming from a trusted, internal source, however, and the routine's design is based on the assumption that these values will be within their valid ranges, then assertions are appropriate.

### For highly robust code, assert and then handle the error anyway
conditions that should always be true are asserted, but such errors are also handled by error-handling code in case the assertion fails

### Don't use an exception to pass the buck 
If an error condition can be handled locally, handle it locally. Don't throw an uncaught exception in a section of code if you can handle the error locally.

### Avoid throwing exceptions in constructors and destructors unless you catch them in the same place 
In C++, for example, destructors aren't called unless an object is fully constructed, which means if code within a constructor throws an exception, the destructor won't be called, thereby setting up a possible resource leak (Meyers 1996, Stroustrup 1997). Similarly complicated rules apply to exceptions within destructors.

### Throw exceptions at the right level of abstraction
When you choose to pass an exception to the caller, make sure the exception's level of abstraction is consistent with the routine interface's abstraction.

bad practice:

	class Employee {
	  ...
	  public TaxId GetTaxId() throws EOFException {     
	    ...
	  }
	}
good :

	class Employee {
	  ...
	  public TaxId GetTaxId() throws EmployeeDataNotAvailable {      
	    ...
	  }
	  ...
	}
	
### Include in the exception message all information that led to the exception
 If the exception was thrown because of an array index error, be sure the exception message includes the upper and lower array limits and the value of the illegal index.
 
### Avoid empty catch blocks
If you really want to ignore the exception, at least do some logging ==

### Know the exceptions your library code throws
be sure you know what exceptions are thrown by any library code you use. Failing to catch an exception generated by library code will crash your program just as fast as failing to catch an exception you generated yourself.

### Consider building a centralized exception reporter

### Consider alternatives to exceptions 
Handling errors with exceptions just because your language provides exception handling is a classic example of programming in a language rather than programming into a language.

Finally, consider whether your program really needs to handle exceptions, period. As Bjarne Stroustrup points out, sometimes the best response to a serious run-time error is to release all acquired resources and abort. Let the user rerun the program with proper input


## Checklist: Defensive Programming
### General
* Does the routine protect itself from bad input data?
* Have you used assertions to document assumptions, including preconditions and postconditions?
* Have assertions been used only to document conditions that should never occur?
* Does the architecture or high-level design specify a specific set of error-handling techniques?
* Does the architecture or high-level design specify whether error handling should favor robustness or correctness?
* Have barricades been created to contain the damaging effect of errors and reduce the amount of code that has to be concerned about error processing?
* Have debugging aids been used in the code?
* Have debugging aids been installed in such a way that they can be activated or deactivated without a great deal of fuss?
* Is the amount of defensive programming code appropriate—neither too much nor too little?
* Have you used offensive-programming techniques to make errors difficult to overlook during development?

### Exceptions
* Has your project defined a standardized approach to exception handling?
* Have you considered alternatives to using an exception?
* Is the error handled locally rather than throwing a nonlocal exception, if possible?
* Does the code avoid throwing exceptions in constructors and destructors?
* Are all exceptions at the appropriate levels of abstraction for the routines that throw them?
* Does each exception include all relevant exception background information?
* Is the code free of empty catch blocks? (Or if an empty catch block truly is appropriate, is it documented?)

###Security Issues
* Does the code that checks for bad input data check for attempted buffer overflows, SQL injection, HTML injection, integer overflows, and other malicious inputs?
* Are all error-return codes checked?
* Are all exceptions caught?
* Do error messages avoid providing information that would help an attacker break into the system?


## design a routine
* Check the prerequisites
* define the problems the routine will solve
* name the routine
* decide how to test the routine
* search already available libraries first. DRY
* think about error handling
* think about efficiency
* write pseudocode
* coding along the pseudocode
* refactor